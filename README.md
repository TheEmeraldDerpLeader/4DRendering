# 4DRendering
A 4D rendering system that I have been working on.

Summary:
  This project is a 4D renderer that takes an approach to rendering called the cross-sectional approach.
You may have heard of something called "4D projections" before: this is completely different. Put simply, the cross-sectional approach takes a "slice" of the 4D world and uses that slice to render what you see. This slice is actually a 3D space rather than a 2D plane since a 3D space is flat in 4-space. 4D objects have a surface made up of 3D cells. These cells create a face when they cross your viewing slice. Each cell of a 4D object will only ever create one face. For example, a pentachoron (4D tetrahedron) has 5 cells and will appear with at most 5 faces. However, it is not necessary that every cell can intersect at the same time as all the others. Furthermore, cross-sections don't always have the same number of edges. This creates interesting shapes and animations by rotating and moving in 4D.

Inspiration:
  Ironically, the first place I heard of the "fourth dimension" and became interested in it was from the rubbish book A Wrinkle In Time by Madeleine L'Engle during 5th or 6th grade (and they made a movie for it! Smh). If I remember correctly, the book was supposed to be some kind of bridge between science and religion (because science and religion are totally conflicting. \s). Anyway, the book throws in the concept of "4D" to make it seem cooler (which clearly worked, darn you Disney!). After this, I learned about the other "dimension" ruses: 4D movies, alternate dimension plotlines, that whole "time is 4D" debate, the thousand tesseract projection pictures, yet no actual mathematics. This is in part because a failure to properly name and classify things as well as meaningless hype; However, I don't think dimension plotlines are bad. For example, dimension is can refer to Physics dimensions (time debate), other universes (I think in Into the Spiderverse uses dimension a few times, but also universe), or mathematical dimensions (like this project). Furthermore, there are multiple kinds of mathematical dimensions, but when a mathematician says dimension they are typically referring to Euclidean dimensions. Later, I learned about Miegakure, a puzzle and platforming game in 4D! It really inspired me, but at the time I didn't know programming and saw it as a potential, potential dream!
  
The Interperiod:
  Later when I did learn to program, this idea of a 4D game always intrigued me. After learning Scratch, Unity C#, and a version of BASIC that you can make on your phone (R.I.P. LowRes Coder), I entered 9th grade. It was then that I first learned of the wonders of mathematics. Geometry that year was falling at the seams: the original teacher (who was a coach) changed to another position, so we got a new teacher that no one took seriously because of his strong east-European accent. After a few weeks, I decided to strike off on my own and go through the Geometry book independently. I went through sections quickly while learning everything excellently...and then some. Not only did I remember, but I understood. I feel as though that is core of the education system does: remembering over understanding. During that year I first started my habits of working on my own maths projects on graph paper during classes (notable works are quaternion knowledge and a hand-rendered cube). One thing the confused me was the book's proof for the surface area of a sphere. In turn, I derived my own after weeks of work which I have published here on Github: https://github.com/TheEmeraldDerpLeader/Surface-Area-of-Sphere .
  
Reamerging Inspiration:
  Nearing the end of the 9th grade, I suddenly became refascinated with the 4th dimension. I believe this was because of my newfound understanding of mathmatics. I studied all I could find on it and also decided to eventually create a rendering system for it. I learned many things: cross-sections, properties of 4D geometry, and OpenCL, a way to execute code on the GPU with C. During that year, I had also learned basic Calculus and Linear Algebra from 3b1b. Inspired, I vowed to learn C++, the ultimate computer language from it's possibilities and use by the big corporations such as Nintendo. Throughout the start of summer, I succeeded in learning C++ as well as learning how to use OpenGL. I started a Minecraft clone to learn C++ and OpenGL(actually not a bad idea). With only a month left, I looked to my goal of creating a 4D renderer (originally 4D Minecraft, which I now know to be too performance intensive). In this time I learnded how to use OpenCL while still working on my Minecraft clone. Eventually, my Minecraft project became very hard to work with, but I had also learned how to use OpenCL. At this point, I decided to attempt to create a 4D rendering system. Unfortunately, I didn't have enough time to get visual results, and school started up again. But nonetheless, I continued to work on it, and I got it set up and working. I continued on whenever I could afford time and got quite far before the burden of homework and school became large enough to make working on it painful and tiring rather than exciting.

???????????Part 4 for next Summer????????????

Algorithm Part 1:
  To start, line data is generated and passed into a kernel, or a program that executes on the GPU but isn't a shader. Practically, this data is made by copying models and applying a transformation, but it can also be manually passed or generated by a function (functions in the complex domain are 4D, they have 2-value inputs and outputs. This implies that they have a 3D surface). This line data is made of a 4D position vector and 4D direction vector. The point and direction vectors create one of the lines of a tetrahedra cell. The line is then transformed into camera space, and the intersection of the line and the space where w = 0 is found and copied in place of the position vector (which now only has xyz coordinates). If the intersection extends farther than the line or is behind the line, then the line is flagged as not intersecting.
  
Algorithm Part 2:
  6 lines are passed together since a tetrahedron has 6 lines. Tetrahedra are used because they can recreate any 3D shape, although having a special rendering path for a specific 3D shape is faster (technically, this part of the algorithm is at worst O(nlog(n)), but I am unsure of how the number of tetrahedra for increase for more complex shapes). If less then three points intersected, then the kernel stops. Otherwise the points that did intersect a passed to a local array for easier manipulation. Next, the points are known to be coplanar (cross-section of a 3D shape is a plane), so a special formula is used to put them in terms of a plane defined by three of the points. This formula is created by solving the parametric forms of the intersection of a plane and a point in 3-space. Next, the points need to be put in clock-wise order to easily generate a triangle mesh for them.
  
Algorithm Part 3:
  To start, the centroid (the average) of the points is found, the points are put in space relative to the centroid, and the points are seperated as either left or right of the origin. Next, a value related to the angle between the each point and the x-axis is found. This value is the magnitude squared of a line from the origin to the point which is then divided from the signed square of the y coordinate. The resulting value is related to the sin of the angle and you can prove this using the fact that the cross product of A and B is |A||B|sin(angle). Since sin is reversisble between angles -90 and 90 and we have seperated the coordinates with angles greater than 90 (left side of origin), we can sort each group of vertices. I am currently using insert sort for this, but this can be optimized to merge or heap sort to create an algorithm which is O(nlog(n)) time complexity (n is the number of lines). Now the original point data created by the intersection is reorganized so they are clockwise and then passed back to the main program along with a value indicating how many points passed. This information is then used to generate a face from a cell which combined with the other cells creates an enclosed 3D cross-section!

Models and Textures:
  Since the surface of a 4D object is 3D, so must be the textures. As such, the textures are enormous and impossible to manually create. For this, I plan to procedurally generate the textures when needed and free them when not used. Texture vertices are created similar to how face vertices are created (in the above section). Textures are created in Program.cpp whereas models are created in RenderObjects.cpp.
  
Current state:
  At the time of writing, the project contains three models: two pentachora (one regular) and a tetrahedral prism. There are 7 texture presets, and each renderable can have it's own texture assigned to it. Models are easy to put in and use. Lastly, there is a prismify function which takes in a triangle and two vectors (model position and textures) and outputs a triangular prism.

Basic Controls:
  The controls are made for being a first-person game. WASD for forward, left, back, right. Q and E for down and up respectively. And you can hold left shift to move faster or right shift to move slower. Press escape to end the program. Press L to toggle the cursor and stop input.
  
4D Controls:
  Here is where 4D comes into play. The keys 1 and 3 are used for -w and +w directions respectively. Left control is used to rotate along the XW and YW planes. Hold left control while moving your mouse and you will rotate along these planes. Mouse up-down rotates on the ZW plane while Mouse left-right rotates on the XW plane.

Some useful links:
http://miegakure.com/  Miegakure website
https://www.youtube.com/watch?v=4URVJ3D8e8k The Lazy Engineer's second video on 4D objects
https://www.youtube.com/watch?v=kpOBaf-fADo&list=PLxUGSVLODn4jv-56edPHQYiY-c1yJOp82 My youtube playlist
https://www.youtube.com/watch?v=gB9n2gHsHN4 3b1b video on non-integer dimensions
